(in-package :aaf)

(defclass node ()
  ((x :accessor node-x :initarg :x :initform 0)
   (y :accessor node-y :initarg :y :initform 0)
   (name :accessor node-name :initarg :name)))

(defmethod print-object ((node node) out)
  (print-unreadable-object (node out :type t)
    (with-slots (x y name) node
      (format out ":name ~s :x ~s :y ~s" name x y))))

(defclass arrow ()
  ((from :accessor arrow-from :initarg :from)
   (to :accessor arrow-to :initarg :to)))

(defclass embedding ()
  ((nodes :accessor embedding-nodes :initarg :nodes :initform ())
   (arrows :accessor embedding-arrows :initarg :arrows :initform ())))

(defun embed (aaf)
  (let* ((nodes (mapcar (lambda (a) (make-instance 'node :x (random 1.0) :y (random 1.0) :name a))
			(aaf-arguments aaf)))
	 (arrows (mapcar (lambda (att)
			    (flet ((find-node (a)
				     (find a nodes :key #'node-name)))
			      (destructuring-bind (a b) att
				(let ((na (find-node a))
				      (nb (find-node b)))
				(make-instance 'arrow :from na :to nb)))))
			 (aaf-attacks aaf))))
    (make-instance 'embedding :nodes nodes :arrows arrows)))

(defclass embedder ()
  ())

(defgeneric embed-step (embedder embedding))

(defgeneric embedder-finished-p (embedder embedding))

(defun sqr (x)
  (* x x))

(defclass fr (embedder)
  ((temp :accessor fr-temp :initarg :temp :initform 1.0)
   (k :accessor fr-k :initarg :k :initform 0.7)))

(defmethod embedder-finished-p ((fr fr) (e embedding))
  (< (fr-temp fr) 0.01))

(defun vector-difference (n1 n2)
  (let* ((dx (- (node-x n1) (node-x n2)))
	 (dy (- (node-y n1) (node-y n2)))
	 (d (max 0.0001 (sqrt (+ (sqr dx) (sqr dy))))))
    (values (/ dx d) (/ dy d) d)))

(defun attractive-force-on-node (fr e node &aux (k (fr-k fr)))
  (let ((fx 0) (fy 0))
    (dolist (n2 (embedding-nodes e))
      (dolist (arrow (embedding-arrows e))
	(when (have-arrow e node n2)
	  #+nil(when (or (and (eql node (arrow-from arrow))
			 (eql n2 (arrow-to arrow)))
			 (and (eql node (arrow-to arrow))
			      (eql n2 (arrow-from arrow)))))
	  (multiple-value-bind (ex ey d) (vector-difference node n2)
	    (let ((fa (/ (sqr d) k)))
	      (incf fx (* 0.1 -1.0 fa ex))
	      (incf fy (* 0.1 -1.0 fa ey)))))))
    (list fx fy)))

(defun have-arrow (e n1 n2)
  (dolist (arrow (embedding-arrows e))
    (when (or (and (eql n1 (arrow-from arrow))
		   (eql n2 (arrow-to arrow)))
	      (and (eql n1 (arrow-to arrow))
		   (eql n2 (arrow-from arrow))))
      (return-from have-arrow t))))

(defun repulsive-force-on-node (fr e node &aux (k (fr-k fr)))
  (let ((fx 0) (fy 0))
    (dolist (n2 (embedding-nodes e))
      (unless (eql node n2)
	(multiple-value-bind (ex ey d) (vector-difference node n2)
	  (let ((fr (if (< d 1.5) (* 30 (/ (sqr k) d))
			(* 0.001 (/ (sqr k) d)))))
	    (incf fx (* fr ex))
	    (incf fy (* fr ey))))))
    (list fx fy)))

(defun force-on-node (fr e node)
  (let* ((fatt (attractive-force-on-node fr e node))
	 (frep (repulsive-force-on-node fr e node))
	 (fx (+ (first fatt) (first frep)))
	 (fy (+ (second fatt) (second frep)))
	 (f (max 0.001 (sqrt (+ (sqr fx) (sqr fy)))))
	 (q (min f (fr-temp fr))))
    (list (* q (/ fx f))
	  (* q (/ fy f)))))

(defmethod embed-step ((fr fr) (e embedding))
  (let ((dqs (mapcar (lambda (node) (force-on-node fr e node)) (embedding-nodes e))))
    (mapcar (lambda (node dq)
	      (incf (node-x node) (first dq))
	      (incf (node-y node) (second dq)))
	    (embedding-nodes e) dqs)
    (setf (fr-temp fr) (* (fr-temp fr) 0.99))))
